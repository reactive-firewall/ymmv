# System-wide .bashrc file for interactive bash(1) shells.

# To enable the settings / commands in this file for login shells as well,
# this file has to be sourced in /etc/profile.
if [[ ( `umask` -le 27 ) ]] ; then umask 022 ; fi ;

# configure paths
function pathappend() {
  for ARG in "$@" ; do
    if [[ -d "$ARG" ]] && [[ ":$PATH:" != *":$ARG:"* ]] ; then
        PATH="${PATH:+"$PATH:"}$ARG" ;
	export PATH ;
    fi
  done
}

pathappend ${HOME}/homebrew/sbin
pathappend ${HOME}/homebrew/bin
pathappend ${HOME}/bin
pathappend /Applications/Docker.app/Contents/Resources/bin/

# If not running interactively, don't do anything
[ -z "$PS1" ] && return
umask 027
# enable this to force color use
#export CAN_USE_COLOR_IN_ENVIORMENT=1 ;

if [[ ( -r /etc/environment ) ]] ; then
	if [[ ( ${FORCE_RELOAD_BASH_ENV:-2} -ge 1 ) ]] ; then
		source /etc/environment ;
		export FORCE_RELOAD_BASH_ENV=0;
	fi
fi

# harden homebrew
export HOMEBREW_NO_ANALYTICS=1 ;
export HOMEBREW_NO_INSECURE_REDIRECT=1 ;
export HOMEBREW_CASK_OPTS=--require-sha ;

#--------------------------------------------------------------
#  Automatic setting of $DISPLAY (if not set already).
#  This works for me - your mileage may vary. . . .
#  The problem is that different types of terminals give
#+ different answers to 'who am i' (rxvt in particular can be
#+ troublesome) - however this code seems to work in a majority
#+ of cases.
#--------------------------------------------------------------

function get_xserver ()
{
    case $TERM in
        xterm*color)
            XSERVER=$(who am i | grep -oE "([12]?[0-9]?[0-9]{1}[\.]{1}){3}([12]?[0-9]?[0-9]{1}){1}" | head -n 1 ) ;
            # Ane-Pieter Wieringa suggests the following alternative:
            #  I_AM=$(who am i)
            #  SERVER=${I_AM#*(}
            #  SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*} ;
            CAN_USE_COLOR_IN_ENVIORMENT=1 ;
            ;;
        xterm*)
            XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' )
            # Ane-Pieter Wieringa suggests the following alternative:
            #  I_AM=$(who am i)
            #  SERVER=${I_AM#*(}
            #  SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*}
            ;;
        aterm | rxvt)
            # Find some code that works here. ...
            ;;
    esac
}

if [ -z ${DISPLAY:=""} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) ||
       ${XSERVER} == "unix" ]]; then
          DISPLAY=":0.0"          # Display on local host.
    else
       DISPLAY=${XSERVER}:0.0     # Display on remote host.
    fi
fi



declare USE_COLOR_IN_ENVIORMENT="${USE_COLOR_IN_ENVIORMENT:-${CAN_USE_COLOR_IN_ENVIORMENT:=0}}" ;

export DISPLAY ;
export USE_COLOR_IN_ENVIORMENT ;
export TZ='America/Los_Angeles'

#-------------------------------------------------------------
# Some settings
#-------------------------------------------------------------

#set -o nounset     # These  two options are useful for debugging.
#set -o xtrace
alias debug="set -o nounset; set -o xtrace"

ulimit -S -c 0      # Don't want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof


# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion
shopt -s cmdhist
shopt -s histappend histverify
shopt -s extglob       # Necessary for programmable completion.
shopt -s hostcomplete
shopt -s interactive_comments
#shopt -s huponexit


# Disable options:
shopt -u mailwarn
unset MAILCHECK        # Don't want my shell to warn me of incoming mail.
#

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

#-------------------------------------------------------------
# Greeting, motd etc...
#-------------------------------------------------------------
# Define some colors first:

# <=---------- Red ----------=>
declare red=${red:='\e[0;31m'};
declare RED=${RED:='\e[1;31m'};
declare On_Red=${On_Red:='\e[41m'};
# <=--------- Green ---------=>
declare green=${green:='\e[0;32m'};
declare GREEN=${GREEN:='\e[1;32m'};
declare On_Green=${On_Green:='\e[42m'};
# <=-------- Yellow ---------=>
declare yellow=${yellow:='\e[0;33m'};
declare YELLOW=${YELLOW:='\e[1;33m'};
declare On_Yellow=${On_Yellow:='\e[43m'};
# <=--------- Blue ----------=>
declare blue=${blue:='\e[0;34m'};
declare BLUE=${BLUE:='\e[1;34m'};
declare On_Blue=${On_Blue:='\e[44m'};
declare cyan=${cyan:='\e[0;36m'};
declare CYAN=${CYAN:='\e[1;36m'};
declare On_Cyan=${On_Cyan:='\e[46m'};
# <=-------- Megenta --------=>
declare megenta=${megenta:='\e[0;35m'};
declare MEGENTA=${MEGENTA:='\e[1;35m'};
declare On_Megenta=${On_Megenta:='\e[45m'};
# <=----- Black & White -----=>
declare black=${black:='\e[0;30m'};
declare white=${white:='\e[0;37m'};
declare WHITE=${WHITE:='\e[1;37m'};
# Background
declare On_Black=${On_Black:='\e[40m'};
declare On_White=${On_White:='\e[47m'};

declare NC='\e[0m' ;            # No Color
declare UNDERLINE='\e[4;1m' ;   # Underline
# --> Nice. Has the same effect as using "ansi.sys" in DOS.


if [[ $USE_COLOR_IN_ENVIORMENT -ge 1 ]] ; then
export red ;
export RED ;
export On_Red ;
export green ;
export GREEN ;
export On_Green ;
export yellow ;
export YELLOW ;
export On_Yellow ;
export blue ;
export BLUE ;
export On_Blue ;
export cyan ;
export CYAN ;
export On_Cyan ;
export On_White ;
export white ;
export WHITE ;
export On_Black ;
export black ;
export BLACK ;
export NC ;

ALERT="${WHITE}${On_Red}" ; # Bold White on red background

export ALERT ;

function alertMessage() {
printf "${NC}${ALERT} ${@} ${NC}\n" ;
return ;
}

alias grep='grep --color=auto' ;
alias ls='ls -G' ;
alias echo='\echo -e' ;

function _exit()              # Function to run upon exit of shell.
{
    echo -e "${RED}Goodbye ${LOGNAME}${NC}" ;
}

else

function _exit()              # Function to run upon exit of shell.
{
    echo "Goodbye ${LOGNAME}"
}

fi

trap _exit EXIT
trap _exit QUIT

if [[ $USE_COLOR_IN_ENVIORMENT -ge 1 ]] ; then

# Test connection type:
if [ -n "${SSH_CONNECTION}" ]; then
    CNX=${BLUE}        # Connected on remote machine, via ssh (good).
elif [[ "${DISPLAY%%:0*}" != "" ]]; then
    CNX=${ALERT}        # Connected on remote machine, not via ssh (bad).
else
    CNX=${WHITE}        # Connected on local machine.
fi

# Test user type:
if [[ ${USER} == "root" ]]; then
    SU=${RED}           # User is root.
elif [[ ${USER} != $(logname) ]]; then
    SU=${yellow}          # User is not login user.
else
    SU=${NC}         # User is normal (well ... most of us are).
fi

NCPU=1
if [[ ( `uname -s` == "Darwin" ) ]] ; then
NCPU=4
else
NCPU=$(grep -c 'processor' /proc/cpuinfo 2>/dev/null)    # Number of CPUs
fi
SLOAD=$(( 100*${NCPU:-1} ))        # Small load
MLOAD=$(( 200*${NCPU:-1} ))        # Medium load
XLOAD=$(( 400*${NCPU:-1} ))        # Xlarge load

# Returns system load as percentage, i.e., '40' rather than '0.40)'.
function load()
{
  if [[ ( `uname -s` == "Darwin" ) ]] ; then
    local SYSLOAD=$(uptime | cut -d: -f4 | cut -d\  -f2 | tr -d '.')
    # System load of the current host.
    echo -n $((10#$SYSLOAD))       # Convert to decimal.
  else
    local SYSLOAD=$(cut -d\  -f1 /proc/loadavg | tr -d '.')
    # System load of the current host.
    echo $((10#$SYSLOAD))       # Convert to decimal.
  fi
}

# Returns a color indicating system load.
function load_color()
{
    local SYSLOAD=$(load)
    if [ ${SYSLOAD} -gt ${XLOAD} ]; then
        echo -en "${ALERT}" ;
    elif [ ${SYSLOAD} -gt ${MLOAD} ]; then
        echo -en "${red}" ;
    elif [ ${SYSLOAD} -gt ${SLOAD} ]; then
        echo -en "${RED}" ;
    else
        echo -en "${green}" ;
    fi
}

# Returns a color according to free disk space in $PWD.
function disk_color()
{
    if [ ! -w "${PWD}" ] ; then
        echo -en "${red}" ;
        # No 'write' privilege in the current directory.
    elif [ -s "${PWD}" ] ; then
        local used=$(command df -P "$PWD" |
                   awk 'END {print $5} {sub(/%/,"")}' | grep -oE "\d+" | tail -n +1 )
        if [ ${used} -gt 95 ]; then
            echo -en "${ALERT}" ;           # Disk almost full (>95%).
        elif [ ${used} -gt 90 ]; then
            echo -en "${RED}" ;            # Free disk space almost gone.
	elif [ ${used} -gt 80 ]; then
            echo -en "${yellow}" ;            # Free disk space rather low.
        else
            echo -en "${GREEN}" ;           # Free disk space is ok.
        fi
    else
        echo -en "${green}" ;
        # Current directory is size '0' (like /proc, /sys etc).
    fi
}

# Returns a color according to running/suspended jobs.
function job_color()
{
    if [ $(jobs -s | wc -l) -gt "0" ]; then
        echo -en "${RED}" ;
    elif [ $(jobs -r | wc -l) -gt "0" ] ; then
        echo -en "${CYAN}" ;
    fi
}

# Adds some text in the terminal frame (if applicable).


# Now we construct the prompt.
PROMPT_COMMAND="history -a"
case ${TERM} in
  *term | *term-*color | rxvt | linux)
        PS1="\["$(load_color)"\][\A\[${NC}\] "
        # Time of day (with load info):
        PS1="\["$(load_color)"\][\A\[${NC}\] "
        # User@Host (with connection type info):
        PS1=${PS1}"\[${SU}\]\u\[${NC}\]@\[${CNX}\]\h\[${NC}\] "
        # PWD (with 'disk space' info):
        PS1=${PS1}"\["$(disk_color)"\]\W]\[${NC}\] "
        # Prompt (with 'job' info):
        PS1=${PS1}"\["$(job_color)"\]>\[${NC}\] "
        # Set title of current xterm:
        PS1=${PS1}'\[\e]0;[\u@\h] \w\a\]' ;
        ;;
    *)
        PS1="(\A \u@\h \W) > " # --> PS1="(\A \u@\h \w) > " ;
                               # --> Shows full pathname of current dir.
        ;;
esac

	export HISTTIMEFORMAT="[%y/%m/%d %H:%M:%S] ";

#-------------------------------------------------------------
# Tailoring 'less'
#-------------------------------------------------------------

alias more='less'
export PAGER=less
export LESSCHARSET='utf-8'
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-' ;
                # Use this if lesspipe.sh exists.
export LESS="-i -w  -z-4 -g -h30 -M -X -F -R -P%t?f%f " ;
# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\e[01;31m'
export LESS_TERMCAP_md=$'\e[01;31m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;44;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[01;32m'

else
	alias more='less'
	export PAGER=less
	export LESSCHARSET='utf-8'
	export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-'
                # Use this if lesspipe.sh exists.
	export LESS='-i -d -w  -z-4 -g -h30 -m -X -F -R -P%t?f%f '

	PS1="\A \u@\h \W --> " ;
	export HISTTIMEFORMAT="[%y/%m/%d %H:%M:%S] " ;

fi

export TIMEFORMAT=$"\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n" ;
export HISTIGNORE="&:bg:fg:ll:h" ;

# ======================= END =======================

# set variable identifying the chroot you work in (used in the prompt below)
#if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
#    debian_chroot=$(cat /etc/debian_chroot)
#fi

# set a fancy prompt (non-color, overwrite the one in /etc/profile)
#PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

# Commented out, don't overwrite xterm -T "title" -n "icontitle" by default.
# If this is an xterm set the title to user@host:dir
#case "$TERM" in
#xterm*|rxvt*)
#    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
#    ;;
#*)
#    ;;
#esac

# enable bash completion in interactive shells
#if ! shopt -oq posix; then
#  if [ -f /usr/share/bash-completion/bash_completion ]; then
#    . /usr/share/bash-completion/bash_completion
#  elif [ -f /etc/bash_completion ]; then
#    . /etc/bash_completion
#  fi
#fi

# set up man page search
declare -x MANPATH="${MANPATH:-/usr/share/man:/usr/local/share/man}:${HOME}/.lib/doc/man"

# if the command-not-found package is installed, use it
if [ -x /usr/lib/command-not-found -o -x /usr/share/command-not-found/command-not-found ]; then
	function command_not_found_handle {
	        # check because c-n-f could've been removed in the meantime
                if [ -x /usr/lib/command-not-found ]; then
		   /usr/lib/command-not-found -- "$1"
                   return $?
                elif [ -x /usr/share/command-not-found/command-not-found ]; then
		   /usr/share/command-not-found/command-not-found -- "$1"
                   return $?
		else
		   printf "%s: command not found\n" "$1" >&2
		   return 127
		fi
	}
fi
