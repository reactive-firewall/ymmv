# System-wide .bashrc file for interactive bash(1) shells.

# To enable the settings / commands in this file for login shells as well,
# this file has to be sourced in /etc/profile.
if [[ ( `umask` -le 27 ) ]] ; then umask 022 ; fi ;
# If not running interactively, don't do anything
[ -z "$PS1" ] && return
umask 027
# enable this to force color
#export CAN_USE_COLOR_IN_ENVIORMENT=1 ;

#--------------------------------------------------------------
#  Automatic setting of $DISPLAY (if not set already).
#  This works for me - your mileage may vary. . . .
#  The problem is that different types of terminals give
#+ different answers to 'who am i' (rxvt in particular can be
#+ troublesome) - however this code seems to work in a majority
#+ of cases.
#--------------------------------------------------------------

function get_xserver ()
{
    case $TERM in
        xterm*color)
            XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' ) ;
            # Ane-Pieter Wieringa suggests the following alternative:
            #  I_AM=$(who am i)
            #  SERVER=${I_AM#*(}
            #  SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*} ;
            CAN_USE_COLOR_IN_ENVIORMENT=1 ;
            ;;
        xterm)
            XSERVER=$(who am i | awk '{print $NF}' | tr -d ')''(' )
            # Ane-Pieter Wieringa suggests the following alternative:
            #  I_AM=$(who am i)
            #  SERVER=${I_AM#*(}
            #  SERVER=${SERVER%*)}
            XSERVER=${XSERVER%%:*}
            ;;
        aterm | rxvt)
            # Find some code that works here. ...
            ;;
    esac
}

if [ -z ${DISPLAY:=""} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) ||
       ${XSERVER} == "unix" ]]; then
          DISPLAY=":0.0"          # Display on local host.
    else
       DISPLAY=${XSERVER}:0.0     # Display on remote host.
    fi
fi



declare USE_COLOR_IN_ENVIORMENT="${USE_COLOR_IN_ENVIORMENT:-${CAN_USE_COLOR_IN_ENVIORMENT:=0}}" ;

export DISPLAY ;
export USE_COLOR_IN_ENVIORMENT ;

#-------------------------------------------------------------
# Some settings
#-------------------------------------------------------------

#set -o nounset     # These  two options are useful for debugging.
#set -o xtrace
alias debug="set -o nounset; set -o xtrace"

ulimit -S -c 0      # Don't want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof


# Enable options:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s sourcepath
shopt -s no_empty_cmd_completion
shopt -s cmdhist
shopt -s histappend histverify
shopt -s extglob       # Necessary for programmable completion.
shopt -s hostcomplete
shopt -s interactive_comments
#shopt -s huponexit


# Disable options:
shopt -u mailwarn
unset MAILCHECK        # Don't want my shell to warn me of incoming mail.
#

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

#-------------------------------------------------------------
# Greeting, motd etc...
#-------------------------------------------------------------
# Define some colors first:

# <=---------- Red ----------=>
declare red=${red:="\E[0;31m"};
declare RED=${RED:="\E[1;31m"};
declare On_Red=${On_Red:="\E[41m"};
# <=--------- Green ---------=>
declare green=${green:="\E[0;32m"};
declare GREEN=${GREEN:="\E[1;32m"};
declare On_Green=${On_Green:="\E[42m"};
# <=-------- Yellow ---------=>
declare yellow=${yellow:="\E[0;33m"};
declare YELLOW=${YELLOW:="\E[1;33m"};
declare On_Yellow=${On_Yellow:="\E[43m"};
# <=--------- Blue ----------=>
declare blue=${blue:="\E[0;34m"};
declare BLUE=${BLUE:="\E[1;34m"};
declare On_Blue=${On_Blue:="\E[44m"};
declare cyan=${cyan:="\E[0;36m"};
declare CYAN=${CYAN:="\E[1;36m"};
declare On_Cyan=${On_Cyan:="\E[46m"};
# <=-------- Megenta --------=>
declare megenta=${megenta:="\E[0;35m"};
declare MEGENTA=${MEGENTA:="\E[1;35m"};
declare On_Megenta=${On_Megenta:="\E[45m"};
# <=----- Black & White -----=>
declare black=${black:="\E[0;30m"};
declare white=${white:="\E[0;37m"};
declare WHITE=${WHITE:="\E[1;37m"};
# Background
declare On_Black=${On_Black:="\E[40m"};
declare On_White=${On_White:="\E[47m"};

declare NC="\e[0m" ;            # No Color
declare UNDERLINE="\E[4;1m" ;   # Underline
# --> Nice. Has the same effect as using "ansi.sys" in DOS.


if [[ $USE_COLOR_IN_ENVIORMENT -ge 1 ]] ; then
export red ;
export RED ;
export On_Red ;
export green ;
export GREEN ;
export On_Green ;
export yellow ;
export YELLOW ;
export On_Yellow ;
export blue ;
export BLUE ;
export On_Blue ;
export cyan ;
export CYAN ;
export On_Cyan ;
export On_White ;
export white ;
export WHITE ;
export On_Black ;
export black ;
export BLACK ;
export NC ;

ALERT="${WHITE}${On_Red}" ; # Bold White on red background

export ALERT ;

function alertMessage() {
printf "${NC}${ALERT} ${@} ${NC}\n" ;
return ;
}

alias grep='grep --color=auto' ;
alias ls='ls -G' ;
alias echo='\echo -e' ;

function _exit()              # Function to run upon exit of shell.
{
    echo -e "${RED}Goodbye ${LOGNAME}${NC}" ;
}

else

function _exit()              # Function to run upon exit of shell.
{
    echo "Goodbye ${LOGNAME}"
}

fi

trap _exit EXIT
trap _exit QUIT

if [[ $USE_COLOR_IN_ENVIORMENT -ge 1 ]] ; then

# Test connection type:
if [ -n "${SSH_CONNECTION}" ]; then
    CNX=${green}        # Connected on remote machine, via ssh (good).
elif [[ "${DISPLAY%%:0*}" != "" ]]; then
    CNX=${ALERT}        # Connected on remote machine, not via ssh (bad).
else
    CNX=${BLUE}        # Connected on local machine.
fi

# Test user type:
if [[ ${USER} == "root" ]]; then
    SU=${RED}           # User is root.
elif [[ ${USER} != $(logname) ]]; then
    SU=${red}          # User is not login user.
else
    SU=${NC}         # User is normal (well ... most of us are).
fi

NCPU=1
if [[ ( `uname -s` = "Darwin" ) ]] ; then
NCPU=4
else
NCPU=$(grep -c 'processor' /proc/cpuinfo 2>/dev/null)    # Number of CPUs
fi
SLOAD=$(( 100*${NCPU} ))        # Small load
MLOAD=$(( 200*${NCPU} ))        # Medium load
XLOAD=$(( 400*${NCPU} ))        # Xlarge load

# Returns system load as percentage, i.e., '40' rather than '0.40)'.
function load()
{
    local SYSLOAD=$(cut -d " " -f1 /proc/loadavg | tr -d '.')
    # System load of the current host.
    echo $((10#$SYSLOAD))       # Convert to decimal.
}

# Returns a color indicating system load.
function load_color()
{
    local SYSLOAD=$(load)
    if [ ${SYSLOAD} -gt ${XLOAD} ]; then
        echo -en "${ALERT}" ;
    elif [ ${SYSLOAD} -gt ${MLOAD} ]; then
        echo -en "${red}" ;
    elif [ ${SYSLOAD} -gt ${SLOAD} ]; then
        echo -en "${RED}" ;
    else
        echo -en "${green}" ;
    fi
}

# Returns a color according to free disk space in $PWD.
function disk_color()
{
    if [ ! -w "${PWD}" ] ; then
        echo -en "${red}" ;
        # No 'write' privilege in the current directory.
    elif [ -s "${PWD}" ] ; then
        local used=$(command df -P "$PWD" |
                   awk 'END {print $5} {sub(/%/,"")}')
        if [ ${used} -gt 95 ]; then
            echo -en "${ALERT}" ;           # Disk almost full (>95%).
        elif [ ${used} -gt 90 ]; then
            echo -en "${RED}" ;            # Free disk space almost gone.
        else
            echo -en "${GREEN}" ;           # Free disk space is ok.
        fi
    else
        echo -en "${green}" ;
        # Current directory is size '0' (like /proc, /sys etc).
    fi
}

# Returns a color according to running/suspended jobs.
function job_color()
{
    if [ $(jobs -s | wc -l) -gt "0" ]; then
        echo -en "${RED}" ;
    elif [ $(jobs -r | wc -l) -gt "0" ] ; then
        echo -en "${CYAN}" ;
    fi
}

# Adds some text in the terminal frame (if applicable).


# Now we construct the prompt.
PROMPT_COMMAND="history -a"
case ${TERM} in
  *term | *term-*color | rxvt | linux)
        PS1="\[\$(load_color)\][\A\[${NC}\] "
        # Time of day (with load info):
        PS1="\[\$(load_color)\][\A\[${NC}\] "
        # User@Host (with connection type info):
        PS1=${PS1}"\[${SU}\]\u\[${NC}\]@\[${CNX}\]\h\[${NC}\] "
        # PWD (with 'disk space' info):
        PS1=${PS1}"\[\$(disk_color)\]\W]\[${NC}\] "
        # Prompt (with 'job' info):
        PS1=${PS1}"\[\$(job_color)\]>\[${NC}\] "
        # Set title of current xterm:
        PS1=${PS1}"\[\e]0;[\u@\h] \w\a\]" ;
        ;;
    *)
        PS1="(\A \u@\h \W) > " # --> PS1="(\A \u@\h \w) > " ;
                               # --> Shows full pathname of current dir.
        ;;
esac

	export HISTTIMEFORMAT="$(echo -e ${CYAN})[%d/%m %H:%M:%S]$(echo -e ${NC}) " ;

#-------------------------------------------------------------
# Tailoring 'less'
#-------------------------------------------------------------

alias more='less'
export PAGER=less
export LESSCHARSET='utf-8'
export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-' ;
                # Use this if lesspipe.sh exists.
export LESS="-i -w  -z-4 -g -h30 -M -X -F -R -P%t?f%f " ;
# LESS man page colors (makes Man pages more readable).
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

else
	alias more='less'
	export PAGER=less
	export LESSCHARSET='utf-8'
	export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-'
                # Use this if lesspipe.sh exists.
	export LESS='-i -d -w  -z-4 -g -h30 -m -X -F -R -P%t?f%f '

	PS1="\A \u@\h \W --> " ;
	export HISTTIMEFORMAT="[%d/%m %H:%M:%S] " ;

fi

export TIMEFORMAT=$"\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n" ;
export HISTIGNORE="&:bg:fg:ll:h" ;

# ======================= END =======================

# set variable identifying the chroot you work in (used in the prompt below)
#if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
#    debian_chroot=$(cat /etc/debian_chroot)
#fi

# set a fancy prompt (non-color, overwrite the one in /etc/profile)
#PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

# Commented out, don't overwrite xterm -T "title" -n "icontitle" by default.
# If this is an xterm set the title to user@host:dir
#case "$TERM" in
#xterm*|rxvt*)
#    PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
#    ;;
#*)
#    ;;
#esac

# enable bash completion in interactive shells
#if ! shopt -oq posix; then
#  if [ -f /usr/share/bash-completion/bash_completion ]; then
#    . /usr/share/bash-completion/bash_completion
#  elif [ -f /etc/bash_completion ]; then
#    . /etc/bash_completion
#  fi
#fi

# set up man page search
declare -x MANPATH="${MANPATH:-/usr/share/man:/usr/local/share/man}:${HOME}/.lib/doc/man"

# sudo hint
if [ ! -e "$HOME/.sudo_as_admin_successful" ] && [ ! -e "$HOME/.hushlogin" ] ; then
    case " $(groups) " in *\ admin\ *)
    if [ -x /usr/bin/sudo ]; then
	cat <<-EOF
	To run a command as administrator (user "root"), use "sudo <command>".
	See "man sudo_root" for details.
	
	EOF
    fi
    esac
fi

# if the command-not-found package is installed, use it
if [ -x /usr/lib/command-not-found -o -x /usr/share/command-not-found/command-not-found ]; then
	function command_not_found_handle {
	        # check because c-n-f could've been removed in the meantime
                if [ -x /usr/lib/command-not-found ]; then
		   /usr/lib/command-not-found -- "$1"
                   return $?
                elif [ -x /usr/share/command-not-found/command-not-found ]; then
		   /usr/share/command-not-found/command-not-found -- "$1"
                   return $?
		else
		   printf "%s: command not found\n" "$1" >&2
		   return 127
		fi
	}
fi

if [[ ( -r /etc/environment ) ]] ; then
	. /etc/environment ;
fi
